{"version":3,"file":"MusicVTest-BFFyWJuM.js","sources":["../../../../components/AceEditor.vue","../../../../lib/musicV.ts","../../../../components/MusicVTest.vue"],"sourcesContent":["<template>\n  <div class=\"ace-editor-container\" ref=\"editorContainer\">\n    <div class=\"editor\" ref=\"editor\"></div>\n  </div>\n</template>\n\n<style scoped>\n.ace-editor-container {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  min-height: 500px;\n  background-color: transparent;\n}\n\n.editor {\n  width: 100%;\n  height: 100%;\n  min-height: 250px;\n  background-color: transparent;\n}\n\n:deep(.ace_editor) {\n  font-family: \"Glass TTY VT220\", \"Courier New\", \"Courier\", monospace;\n  background-color: transparent !important;\n  font-size: 16px !important;\n}\n\n:deep(.ace_editor .ace_line) {\n  padding-left: 0 !important;\n}\n\n:deep(.terminal) {\n  background-color: #000000 !important;\n}\n\n:deep(.terminal .ace_content) {\n  background-color: #000000 !important;\n  color: #ffb000 !important; /* Amber color for vintage terminal look */\n  font-family: \"Glass TTY VT220\", \"Courier New\", \"Courier\", monospace !important;\n  font-size: 18px !important;\n  line-height: 1.2 !important;\n}\n\n:deep(.terminal .ace_cursor) {\n  background-color: #ffb000 !important;\n  border-color: #ffb000 !important;\n}\n\n:deep(.terminal .ace_text-layer) {\n  font-family: \"Glass TTY VT220\", \"Courier New\", \"Courier\", monospace !important;\n}\n\n@font-face {\n  font-family: \"Glass TTY VT220\";\n  src: url(\"/fonts/Glass_TTY_VT220.ttf\") format(\"truetype\");\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap;\n}\n</style>\n\n<script setup>\nimport {\n  onMounted,\n  ref,\n  defineExpose,\n  defineEmits,\n  onUnmounted,\n  nextTick,\n} from \"vue\";\nimport { useRuntimeConfig } from \"#app\";\nimport ace from \"ace-builds/src-noconflict/ace\";\nimport \"ace-builds/src-noconflict/theme-monokai\";\nimport { useRandomPrompt } from \"~/composables/useRandomPrompt\";\nimport \"ace-builds/src-noconflict/mode-text\";\n\nconst props = defineProps({\n  mode: {\n    type: String,\n    default: \"editor\", // 'editor' or 'terminal'\n  },\n});\n\nconst emit = defineEmits([\"evaluate\", \"keydown\"]);\nconst editor = ref(null);\nconst version = ref(\"0.0.0\");\nlet aceEditorInstance;\nconst commandHistory = ref([]);\nlet historyIndex = ref(-1);\nlet currentCommand = ref(\"\");\nconst editorContainer = ref(null);\nconst resizeObserver = ref(null);\n\nconst fetchVersion = async () => {\n  try {\n    const config = useRuntimeConfig();\n    const baseURL = config.public.apiBase || \"http://localhost:10000\";\n    const response = await fetch(`${baseURL}/api/version`);\n    const data = await response.json();\n    if (data.version !== version.value) {\n      version.value = data.version;\n      // Update welcome message when version changes\n      if (aceEditorInstance) {\n        const currentContent = aceEditorInstance.getValue();\n        const newContent = currentContent.replace(\n          /# Welcome to SOOG \\[The Speculative Organology Organogram Generator [0-9.]+\\]/,\n          `# Welcome to SOOG [The Speculative Organology Organogram Generator ${data.version}]`\n        );\n        aceEditorInstance.setValue(newContent);\n        aceEditorInstance.clearSelection();\n      }\n    }\n  } catch (error) {\n    console.error(\"Error fetching version:\", error);\n  }\n};\n\n// Set up polling for version updates\nlet versionPollInterval;\nconst startVersionPolling = () => {\n  // Check version every 30 seconds\n  versionPollInterval = setInterval(fetchVersion, 30000);\n};\n\n// Update font size based on device\nconst updateFontSize = () => {\n  if (!aceEditorInstance) return;\n  const isMobile =\n    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    );\n  aceEditorInstance.setOption(\"fontSize\", isMobile ? \"16px\" : \"20px\");\n};\n\n// Add content to Ace Editor dynamically\nconst addToEditor = (content, type = \"text\") => {\n  const cssClass =\n    type === \"text\"\n      ? \"gpt-text-response\"\n      : type === \"plot\"\n      ? \"gpt-plot-response\"\n      : \"gpt-code-response\";\n  if (!aceEditorInstance) return;\n\n  const session = aceEditorInstance.getSession();\n  const doc = session.getDocument();\n  const currentLength = doc.getLength();\n  const newContent = `\\n\\n${content}\\n\\n`; // Add extra spacing\n\n  doc.insert({ row: currentLength, column: 0 }, newContent);\n\n  // Highlight GPT responses using markers\n  const Range =\n    ace.require(\"ace/range\").Range || ace.require(\"ace/edit_session\").Range;\n  const startRow = currentLength + 1;\n  const endRow = currentLength + newContent.split(\"\\n\").length - 1;\n\n  aceEditorInstance.session.addMarker(\n    new Range(startRow, 0, endRow, 1),\n    cssClass,\n    \"fullLine\"\n  );\n\n  // Scroll to the bottom of the AceEditor and page\n  nextTick(() => {\n    aceEditorInstance.scrollToLine(endRow, true, true, () => {});\n    aceEditorInstance.gotoLine(endRow, 0, true);\n\n    // Ensure the page also scrolls to the bottom\n    const editorElement = editor.value;\n    if (editorElement) {\n      editorElement.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\n    }\n  });\n};\n\n// Clear editor content\nconst clearEditor = () => {\n  if (aceEditorInstance) {\n    aceEditorInstance.session.setValue(\"\");\n    aceEditorInstance.clearSelection();\n  }\n};\n\n// Add to command history\nconst addToHistory = (content) => {\n  if (\n    content.trim() &&\n    commandHistory.value[commandHistory.value.length - 1] !== content\n  ) {\n    commandHistory.value.push(content);\n    historyIndex.value = commandHistory.value.length;\n  }\n};\n\ndefineExpose({\n  addToEditor,\n  aceEditor: () => aceEditorInstance,\n  clearEditor,\n  addToHistory,\n  resize: () => aceEditorInstance?.resize(),\n  terminalInstance: () => aceEditorInstance,\n  aceEditorInstance: () => aceEditorInstance\n});\n\nonMounted(async () => {\n  try {\n    aceEditorInstance = ace.edit(editor.value);\n    aceEditorInstance.setTheme(\"ace/theme/monokai\");\n    aceEditorInstance.session.setMode(\"ace/mode/text\");\n    aceEditorInstance.setOption(\"wrap\", true);\n    aceEditorInstance.setOption(\"printMargin\", false);\n    aceEditorInstance.setOption(\"tabSize\", 2);\n    aceEditorInstance.setOption(\"showGutter\", false);\n\n    // Set initial font size and listen for changes\n    updateFontSize();\n    window.addEventListener(\"resize\", updateFontSize);\n\n    // Get random prompt\n    const { getRandomPrompt } = useRandomPrompt();\n    const prompt = await getRandomPrompt();\n\n    // Fetch version and start polling\n    await fetchVersion();\n    startVersionPolling();\n    aceEditorInstance.setValue(\n      `# Welcome to SOOG [The Speculative Organology Organogram Generator ${version.value}]\\n# Write your invented instrument, select text and press Alt+Enter to evaluate\\n\\n${prompt}\\n`\n    );\n    aceEditorInstance.clearSelection();\n\n    // Add initial prompt to command history\n    addToHistory(prompt);\n\n    // Set up resize observer to handle container size changes\n    resizeObserver.value = new ResizeObserver(() => {\n      if (aceEditorInstance) {\n        aceEditorInstance.resize();\n      }\n    });\n\n    if (editorContainer.value) {\n      resizeObserver.value.observe(editorContainer.value);\n    }\n\n    // Add custom keybindings\n    aceEditorInstance.commands.addCommands([\n      {\n        name: \"evaluateCode\",\n        bindKey: { win: \"Alt-Enter\", mac: \"Alt-Enter\" },\n        exec: () => {\n          const selectedText = aceEditorInstance.getSelectedText();\n          const codeToEvaluate = selectedText || aceEditorInstance.getValue();\n          addToHistory(codeToEvaluate);\n          emit(\"evaluate\", codeToEvaluate);\n        },\n      },\n      {\n        name: \"clearEditor\",\n        bindKey: { win: \"Ctrl-H\", mac: \"Command-H\" },\n        exec: clearEditor,\n      },\n      {\n        name: \"previousCommand\",\n        bindKey: { win: \"Ctrl-Up\", mac: \"Command-Up\" },\n        exec: () => {\n          if (historyIndex.value > 0) {\n            // Save current input if we're starting to navigate history\n            if (historyIndex.value === commandHistory.value.length) {\n              currentCommand.value = aceEditorInstance.getValue();\n            }\n            historyIndex.value--;\n            aceEditorInstance.setValue(\n              commandHistory.value[historyIndex.value]\n            );\n            aceEditorInstance.clearSelection();\n          }\n        },\n      },\n      {\n        name: \"nextCommand\",\n        bindKey: { win: \"Ctrl-Down\", mac: \"Command-Down\" },\n        exec: () => {\n          if (historyIndex.value < commandHistory.value.length) {\n            historyIndex.value++;\n            if (historyIndex.value === commandHistory.value.length) {\n              aceEditorInstance.setValue(currentCommand.value);\n            } else {\n              aceEditorInstance.setValue(\n                commandHistory.value[historyIndex.value]\n              );\n            }\n            aceEditorInstance.clearSelection();\n          }\n        },\n      },\n    ]);\n\n    aceEditorInstance.container.addEventListener(\"keydown\", (event) => {\n      emit(\"keydown\", event);\n    });\n  } catch (error) {\n    console.error(\"AceEditor initialization failed:\", error);\n  }\n});\n\nonUnmounted(() => {\n  window.removeEventListener(\"resize\", updateFontSize);\n  if (versionPollInterval) {\n    clearInterval(versionPollInterval);\n  }\n  if (resizeObserver.value) {\n    resizeObserver.value.disconnect();\n  }\n\n  if (aceEditorInstance) {\n    aceEditorInstance.destroy();\n  }\n});\n</script>\n","/// <reference lib=\"dom\" />\n/// <reference lib=\"dom.iterable\" />\n\n// MusicV implementation based on the original MUSIC V specification\ndeclare global {\n  interface Window {\n    AudioContext: typeof AudioContext;\n    AudioWorkletNode: typeof AudioWorkletNode;\n  }\n}\n\n// Define types for MusicV\ninterface MusicVInstrument {\n  id: number;\n  units: any[];\n  [key: string]: any; // Allow for additional properties\n}\n\n// Define interface for function table data\ninterface FunctionTable {\n  functionNum: number;\n  data: number[];\n}\n\nexport class MusicV {\n  private sampleRate: number = 44100;\n  private parameters: Float32Array;\n  private events: any[] = [];\n  private currentTime: number = 0;\n  private instruments: Map<number, MusicVInstrument> = new Map();\n  private functions: Map<number, Float32Array> = new Map(); // Stored functions F1-F10\n  private currentInstrument: MusicVInstrument | null = null;\n  private audioContext: globalThis.AudioContext | null = null;\n  private workletNode: globalThis.AudioWorkletNode | null = null;\n  private consoleOutput: string = '';\n  private isServer: boolean = typeof globalThis.window === 'undefined';\n  private activeNotes: Map<number, any> = new Map();\n\n  constructor() {\n    this.sampleRate = 44100;\n    this.currentTime = 0;\n    this.events = [];\n    this.instruments = new Map();\n    this.functions = new Map();\n    this.activeNotes = new Map();\n    this.consoleOutput = '';\n    this.parameters = new Float32Array(1000); // Initialize parameters array\n    \n    // Initialize default function tables\n    this.initDefaultFunctionTables();\n  }\n  \n  private initDefaultFunctionTables(): void {\n    // Create F2 - Sine wave\n    const sineWave = new Float32Array(512);\n    for (let i = 0; i < 512; i++) {\n      sineWave[i] = Math.sin(2 * Math.PI * i / 512);\n    }\n    this.functions.set(2, sineWave);\n    \n    // Create F1 - Straight line (for testing)\n    const straightLine = new Float32Array(512);\n    for (let i = 0; i < 512; i++) {\n      straightLine[i] = i / 512;\n    }\n    this.functions.set(1, straightLine);\n  }\n\n  // Parse score text into events (simplified version of Pass1)\n  parseScore(scoreText: string): void {\n    this.consoleOutput = '';\n    this.consoleOutput += '*** MUSIC V SCORE PROCESSING ***\\n\\n';\n    \n    // Split the score into lines\n    const lines = scoreText.split('\\n');\n    \n    // Process each line\n    let currentInstrument: any = null;\n    let currentInstrumentId = -1;\n    let wordCount = 0;\n    \n    // Track instruments and their unit counts for the PASS II report\n    const instrumentUnitCounts = new Map<number, number>();\n    \n    for (const line of lines) {\n      // Skip empty lines\n      if (!line.trim()) {\n        continue;\n      }\n      \n      // Handle comments (COM or COMMENT)\n      if (line.trim().startsWith('COM') || line.trim().startsWith('COMMENT')) {\n        this.consoleOutput += `Comment: ${line.trim().substring(line.trim().indexOf(' ') + 1)}\\n`;\n        continue;\n      }\n      \n      // Skip lines that are just comments (;)\n      if (line.trim().startsWith(';')) {\n        continue;\n      }\n      \n      // Split the line into parts\n      const parts = line.trim().split(/\\s+/);\n      const opcode = parts[0];\n      wordCount += parts.length;\n      \n      // Handle different opcodes\n      if (opcode === 'INS') {\n        // INS P1 P2\n        // P1: Instrument number\n        // P2: Instrument type (optional)\n        \n        // If we were defining an instrument, finalize it\n        if (currentInstrument) {\n          this.consoleOutput += `Instrument ${currentInstrumentId} definition complete\\n\\n`;\n          instrumentUnitCounts.set(currentInstrumentId, currentInstrument.units.length);\n        }\n        \n        currentInstrumentId = parseInt(parts[1], 10);\n        currentInstrument = {\n          id: currentInstrumentId,\n          units: [],\n          oscillators: [],\n          outputs: []\n        };\n        \n        this.consoleOutput += `Defining Instrument ${currentInstrumentId}\\n`;\n        this.instruments.set(currentInstrumentId, currentInstrument);\n      } \n      else if (opcode === 'OSC' && currentInstrument) {\n        // OSC P5 P6 B2 F2 P30\n        // P5: Frequency parameter number (P-field)\n        // P6: Amplitude parameter number (P-field)\n        // B2: Output bus number\n        // F2: Function table number\n        // P30: Initial phase parameter (optional)\n        \n        const freqParam = parts[1];\n        const ampParam = parts[2];\n        const outputBus = parseInt(parts[3].substring(1), 10); // Remove 'B' prefix\n        const functionTable = parseInt(parts[4].substring(1), 10); // Remove 'F' prefix\n        const phaseParam = parts.length > 5 ? parts[5] : 'P30';\n        \n        // Add oscillator to instrument\n        const oscId = currentInstrument.oscillators.length + 1;\n        currentInstrument.oscillators.push({\n          id: oscId,\n          type: 1, // Default to sine\n          freqParam,\n          ampParam,\n          outputBus,\n          functionTable,\n          phaseParam\n        });\n        \n        // Add as unit generator\n        currentInstrument.units.push({\n          type: 'OSC',\n          params: {\n            freqParam,\n            ampParam,\n            outputBlock: outputBus,\n            functionNum: functionTable,\n            phaseParam\n          }\n        });\n        \n        this.consoleOutput += `  OSC: Type=1, Freq=${freqParam}, Amp=${ampParam}, Phase=${phaseParam}, Bus=${outputBus}, Function=${functionTable}\\n`;\n      } \n      else if (opcode === 'OUT' && currentInstrument) {\n        // OUT B2 B1\n        // B2: Input bus number\n        // B1: Output bus number\n        \n        const inputBus = parseInt(parts[1].substring(1), 10); // Remove 'B' prefix\n        const outputBus = parseInt(parts[2].substring(1), 10); // Remove 'B' prefix\n        \n        currentInstrument.outputs.push({\n          inputBus,\n          outputBus\n        });\n        \n        // Add as unit generator\n        currentInstrument.units.push({\n          type: 'OUT',\n          params: {\n            inputBlock: inputBus,\n            outputBlock: outputBus,\n            amplitude: 1.0 // Default amplitude\n          }\n        });\n        \n        this.consoleOutput += `  OUT: Input Bus=${inputBus}, Output Bus=${outputBus}, Amp=1\\n`;\n      } \n      else if (opcode === 'END' && currentInstrument) {\n        this.consoleOutput += `Instrument ${currentInstrumentId} definition complete\\n\\n`;\n        instrumentUnitCounts.set(currentInstrumentId, currentInstrument.units.length);\n        currentInstrument = null;\n      } \n      else if (opcode === 'GEN') {\n        // GEN P1 P2 P3 P4 P5 P6 P7 ...\n        // Format: GEN P1 P2 P3 [P4 P5 P6 P7 ...] ;\n        // P1: Not used currently\n        // P2: Action time (not used currently)\n        // P3: Function table number to generate (F1, F2, etc.)\n        // P4, P5, P6, ... : Pairs of (value, time) for the function table\n        //                   where value is in range [-1, 1] and time is in range [0, 512]\n        \n        const p1 = parseInt(parts[1], 10);\n        const actionTime = parseFloat(parts[2]);\n        const functionNum = parseInt(parts[3], 10);\n        \n        // Extract the value-time pairs\n        const params = [];\n        for (let i = 4; i < parts.length; i++) {\n          if (parts[i] === ';') break;\n          params.push(parseFloat(parts[i]));\n        }\n        \n        this.consoleOutput += `GEN: Function=${functionNum}, Params=${params.length}\\n`;\n        this.handleGenFunction(functionNum, 0, 0, params);\n      }\n      else if (opcode === 'NOT') {\n        // NOT P1 P2 P3 P4 P5\n        // P1: Start time\n        // P2: Instrument number\n        // P3: Frequency\n        // P4: Amplitude\n        // P5: Duration\n        \n        const startTime = parseFloat(parts[1]);\n        const instrumentId = parseInt(parts[2], 10);\n        const frequency = parseFloat(parts[3]);\n        const noteAmplitude = parseFloat(parts[4]);\n        const duration = parseFloat(parts[5]);\n        \n        // Add note start event\n        this.events.push({\n          type: 'note',\n          time: startTime,\n          insNum: instrumentId,\n          frequency,\n          amplitude: noteAmplitude,\n          duration\n        });\n        \n        this.consoleOutput += `Note: Start=${startTime}, Ins=${instrumentId}, Freq=${frequency}, Amp=${noteAmplitude}, Dur=${duration}\\n`;\n      }\n      else if (opcode === 'TER') {\n        // TER P1\n        // P1: Termination time\n        const terminationTime = parseFloat(parts[1]);\n        this.consoleOutput += `Termination time: ${terminationTime}\\n\\n`;\n      }\n    }\n    \n    // Sort events by time\n    this.events.sort((a, b) => a.time - b.time);\n    \n    // Add PASS II style output\n    this.consoleOutput += 'PASS II REPORT\\n';\n    this.consoleOutput += '(WORD CNT)\\n';\n    \n    // Format the instrument unit counts in the style of the original PASS II output\n    instrumentUnitCounts.forEach((unitCount, id) => {\n      // Format with proper spacing to match original output\n      this.consoleOutput += `       ${id}    ${unitCount}.000    0.000\\n`;\n    });\n    \n    this.consoleOutput += 'END OF PASS II\\n\\n';\n    this.consoleOutput += 'Score processing complete\\n';\n  }\n  \n  // Handle GEN function definition\n  private handleGenFunction(functionNum: number, genType: number, normalization: number, params: number[]): void {\n    // Create a function table with 512 points\n    const functionData = new Float32Array(512);\n    \n    // Process based on GEN type\n    if (genType === 0) {\n      // GEN type 0: Line segments between specified points\n      // Params are pairs of (value, time)\n      \n      // First, set the values at the specified positions\n      const points = [];\n      for (let i = 0; i < params.length; i += 2) {\n        const value = params[i] || 0;\n        const position = Math.floor(params[i + 1]);\n        \n        // Ensure position is within bounds\n        if (position >= 0 && position < 512) {\n          points.push({ position, value });\n          // Debug output for troubleshooting\n          this.consoleOutput += `  Point: val=${value}, pos=${position}\\n`;\n        }\n      }\n      \n      // Sort points by position\n      points.sort((a, b) => a.position - b.position);\n      \n      // Ensure we have at least two points\n      if (points.length < 2) {\n        // Add default points if needed\n        if (points.length === 0) {\n          points.push({ position: 0, value: 0 });\n          points.push({ position: 511, value: 0 });\n        } else {\n          // If we have only one point, duplicate it at the end\n          points.push({ position: 511, value: points[0].value });\n        }\n      }\n      \n      // Interpolate between points\n      for (let i = 0; i < points.length - 1; i++) {\n        const startPoint = points[i];\n        const endPoint = points[i + 1];\n        \n        const startPos = startPoint.position;\n        const endPos = endPoint.position;\n        const startVal = startPoint.value;\n        const endVal = endPoint.value;\n        \n        // Linear interpolation between points\n        for (let pos = startPos; pos <= endPos; pos++) {\n          const t = (endPos === startPos) ? 0 : (pos - startPos) / (endPos - startPos);\n          functionData[pos] = startVal * (1 - t) + endVal * t;\n        }\n      }\n      \n      // Debug output for the first few and last few values\n      this.consoleOutput += `  Function table ${functionNum} created with ${points.length} points\\n`;\n      this.consoleOutput += `  Function table values (sample): [0]=${functionData[0].toFixed(3)}, [50]=${functionData[50].toFixed(3)}, [205]=${functionData[205].toFixed(3)}, [306]=${functionData[306].toFixed(3)}, [461]=${functionData[461].toFixed(3)}, [511]=${functionData[511].toFixed(3)}\\n`;\n    } else {\n      // Default to sine wave for unsupported GEN types\n      for (let i = 0; i < 512; i++) {\n        functionData[i] = Math.sin(2 * Math.PI * i / 512);\n      }\n      this.consoleOutput += `Warning: GEN type ${genType} not supported, using sine wave\\n`;\n    }\n    \n    // Apply normalization if requested\n    if (normalization > 0) {\n      // Find min and max values\n      let minVal = Infinity;\n      let maxVal = -Infinity;\n      \n      for (let i = 0; i < 512; i++) {\n        minVal = Math.min(minVal, functionData[i]);\n        maxVal = Math.max(maxVal, functionData[i]);\n      }\n      \n      // Calculate normalization factor\n      let normFactor = 1;\n      if (normalization === 1) {\n        // Normalize to range [-1, 1]\n        normFactor = Math.max(Math.abs(minVal), Math.abs(maxVal));\n      } else if (normalization === 2) {\n        // Normalize to range [0, 1]\n        const range = maxVal - minVal;\n        normFactor = range;\n      }\n      \n      // Apply normalization\n      if (normFactor !== 0) {\n        for (let i = 0; i < 512; i++) {\n          if (normalization === 1) {\n            // Normalize to range [-1, 1]\n            functionData[i] /= normFactor;\n          } else if (normalization === 2) {\n            // Normalize to range [0, 1]\n            functionData[i] = (functionData[i] - minVal) / normFactor;\n          }\n        }\n      }\n    }\n    \n    // Store the function\n    this.functions.set(functionNum, functionData);\n    \n    // Debug output\n    console.log(`Created function table F${functionNum} with ${functionData.length} points`);\n  }\n\n  // Generate audio samples (simplified version of Pass3)\n  async generateSound(duration: number = 8): Promise<Float32Array> {\n    try {\n      // Create a buffer for the output\n      const numSamples = Math.floor(this.sampleRate * duration);\n      const outputBuffer = new Float32Array(numSamples);\n      \n      // Reset time\n      this.currentTime = 0;\n      \n      // Sort events by time\n      this.events.sort((a, b) => a.time - b.time);\n      \n      // Process each sample\n      for (let i = 0; i < numSamples; i++) {\n        // Process any events that should occur at this time\n        const currentTimeInSeconds = i / this.sampleRate;\n        \n        // Check for events that should be processed at this time\n        while (this.events.length > 0 && this.events[0].time <= currentTimeInSeconds) {\n          const event = this.events.shift();\n          if (event) {\n            this.processEvent(event, currentTimeInSeconds);\n          }\n        }\n        \n        // Generate the sample for this time\n        const blocks = new Map<number, Float32Array>();\n        blocks.set(1, new Float32Array(1)); // Initialize output block B1\n        \n        outputBuffer[i] = this.generateSample(currentTimeInSeconds, blocks);\n        \n        // Update time\n        this.currentTime = currentTimeInSeconds;\n      }\n      \n      return outputBuffer;\n    } catch (error: any) {\n      console.error('Error generating sound:', error);\n      this.consoleOutput += `Error generating sound: ${error.message}\\n`;\n      return new Float32Array(0);\n    }\n  }\n\n  private processEvent(event: any, currentTime: number): void {\n    const { type, insNum } = event;\n    \n    switch (type) {\n      case 'note':\n        const instrument = this.instruments.get(insNum);\n        if (instrument) {\n          // Create a copy of the instrument for this note\n          const noteNum = Date.now(); // Unique ID for this note\n          const instrumentCopy = JSON.parse(JSON.stringify(instrument));\n          \n          // Add to active notes with all necessary properties\n          this.activeNotes.set(noteNum, {\n            instrument: instrumentCopy,\n            startTime: currentTime,\n            duration: event.duration,\n            frequency: event.frequency,\n            amplitude: event.amplitude\n          });\n          \n          console.log(`Note started: Instrument=${insNum}, Freq=${event.frequency}, Amp=${event.amplitude}`);\n        } else {\n          this.consoleOutput += `Error: Instrument ${insNum} not found\\n`;\n        }\n        break;\n    }\n  }\n\n  private generateSample(currentTime: number, blocks: Map<number, Float32Array>): number {\n    // Clear all blocks except B1 (output)\n    for (let i = 2; i <= 10; i++) {\n      const block = blocks.get(i);\n      if (block) {\n        block.fill(0);\n      }\n    }\n    \n    // Process all active notes\n    for (const [noteNum, note] of this.activeNotes.entries()) {\n      const noteEndTime = note.startTime + note.duration;\n      \n      if (currentTime >= note.startTime && currentTime <= noteEndTime) {\n        const instrument = note.instrument;\n        \n        if (instrument && instrument.units) {\n          // Process each unit generator in the instrument\n          for (const unit of instrument.units) {\n            switch (unit.type) {\n              case 'OSC':\n                this.processOscillator(unit, note, blocks, currentTime);\n                break;\n                \n              case 'OUT':\n                this.processOutput(unit, blocks);\n                break;\n                \n              // Add other unit generators as needed\n            }\n          }\n        }\n      } else if (currentTime > noteEndTime) {\n        // Remove note if it's finished\n        this.activeNotes.delete(noteNum);\n      }\n    }\n    \n    // Return the sample from the output block (B1)\n    const outputBlock = blocks.get(1);\n    return outputBlock ? outputBlock[0] : 0;\n  }\n  \n  private processOscillator(unit: any, note: any, blocks: Map<number, Float32Array>, currentTime: number): void {\n    // Implement the oscillator algorithm as described in the specification\n    // OSC P5 P6 B2 F2 P30\n    const params = unit.params;\n    const functionNum = params.functionNum || 2; // Default to F2\n    const outputBlockNum = params.outputBlock || 2; // Default to B2\n    \n    // Get the function data\n    const functionData = this.functions.get(functionNum);\n    if (!functionData) {\n      // If function table doesn't exist, create a default sine wave\n      const defaultFunction = new Float32Array(512);\n      for (let i = 0; i < 512; i++) {\n        defaultFunction[i] = Math.sin(2 * Math.PI * i / 512);\n      }\n      this.functions.set(functionNum, defaultFunction);\n    }\n    \n    // Get the output block\n    let outputBlock = blocks.get(outputBlockNum);\n    if (!outputBlock) {\n      // Create the output block if it doesn't exist\n      outputBlock = new Float32Array(1);\n      blocks.set(outputBlockNum, outputBlock);\n    }\n    \n    // Get amplitude and frequency directly from the note object\n    // These were set in processEvent\n    const amplitude = note.amplitude || 0.5;\n    const frequency = note.frequency || 440;\n    \n    // Log values for debugging\n    if (currentTime < 0.01 || Math.abs(currentTime - Math.floor(currentTime * 10) / 10) < 0.001) {\n      console.log(`OSC at ${currentTime.toFixed(2)}s: Freq=${frequency.toFixed(2)}, Amp=${amplitude.toFixed(2)}, Block=${outputBlockNum}, Func=${functionNum}`);\n    }\n    \n    // Initialize oscillator state if needed\n    if (!note.oscState) {\n      note.oscState = { sum: 0 };\n    }\n    \n    // Calculate the increment for the oscillator\n    // I2 = 0.02555 * freq as per the specification\n    const increment = 0.02555 * frequency;\n    \n    // Update the oscillator state\n    note.oscState.sum += increment;\n    \n    // Calculate the index into the function table\n    // [S_i]mod 511 as per the specification\n    const index = Math.floor(note.oscState.sum % 511);\n    \n    // Get the value from the function table\n    const functionTable = this.functions.get(functionNum) || new Float32Array(512);\n    const value = functionTable[index];\n    \n    // Scale by amplitude and store in output block\n    outputBlock[0] = value * amplitude;\n  }\n  \n  private processOutput(unit: any, blocks: Map<number, Float32Array>): void {\n    // Implement the output unit as described in the specification\n    // OUT B2 B1\n    const params = unit.params;\n    const inputBlockNum = params.inputBlock || 2; // Default to B2\n    const outputBlockNum = params.outputBlock || 1; // Default to B1\n    const amplitude = params.amplitude || 1.0; // Default amplitude\n    \n    // Get the input and output blocks\n    const inputBlock = blocks.get(inputBlockNum);\n    let outputBlock = blocks.get(outputBlockNum);\n    \n    if (!inputBlock) {\n      // Input block not found, create an empty one\n      blocks.set(inputBlockNum, new Float32Array(1));\n      return;\n    }\n    \n    if (!outputBlock) {\n      // Output block not found, create it\n      outputBlock = new Float32Array(1);\n      blocks.set(outputBlockNum, outputBlock);\n    }\n    \n    // Add the input to the output (allows combining multiple instruments)\n    outputBlock[0] += inputBlock[0] * amplitude;\n  }\n\n  // Initialize audio context and worklet\n  async initAudio(): Promise<void> {\n    if (!this.audioContext) {\n      try {\n        console.log('Initializing audio context...');\n        // Create audio context with proper sample rate\n        this.audioContext = new AudioContext({ \n          sampleRate: this.sampleRate,\n          latencyHint: 'interactive'\n        });\n        \n        console.log('Audio context created with sample rate:', this.audioContext.sampleRate);\n        \n        // Load worklet module with absolute path\n        const workletUrl = '/musicVWorklet.js';\n        console.log('Loading worklet from URL:', workletUrl);\n        \n        try {\n          await this.audioContext.audioWorklet.addModule(workletUrl);\n          console.log('Worklet module loaded successfully!');\n        } catch (workletError: any) {\n          console.error('Failed to load worklet module:', workletError);\n          throw new Error(`Worklet loading failed: ${workletError.message}`);\n        }\n        \n        // Create and connect worklet node\n        console.log('Creating AudioWorkletNode with processor name: music-v-processor');\n        this.workletNode = new AudioWorkletNode(this.audioContext, 'music-v-processor');\n        this.workletNode.connect(this.audioContext.destination);\n        \n        console.log('Sending initialization data to worklet...');\n        // Initialize worklet with events and instruments\n        this.workletNode.port.postMessage({\n          type: 'init',\n          events: this.events,\n          instruments: Object.fromEntries(this.instruments),\n          functions: Array.from(this.functions).reduce((obj, [key, value]) => {\n            obj[key] = Array.from(value);\n            return obj;\n          }, {} as Record<string, number[]>),\n          sampleRate: this.sampleRate\n        });\n\n        // Handle worklet errors\n        this.workletNode.onprocessorerror = (error: ErrorEvent) => {\n          console.error('Worklet processor error:', error);\n          throw new Error('Audio processing error occurred');\n        };\n\n        // Resume audio context\n        if (this.audioContext.state === 'suspended') {\n          console.log('Resuming audio context...');\n          await this.audioContext.resume();\n          console.log('Audio context resumed:', this.audioContext.state);\n        }\n        \n        console.log('Audio initialization complete!');\n      } catch (error: any) {\n        console.error('Failed to initialize audio worklet:', error);\n        throw new Error(`Failed to initialize audio: ${error.message || 'Unknown error'}`);\n      }\n    }\n  }\n\n  // Start audio playback\n  async play(): Promise<void> {\n    if (!this.audioContext) {\n      await this.initAudio();\n    }\n    \n    if (this.audioContext && this.workletNode) {\n      if (this.audioContext.state === 'suspended') {\n        await this.audioContext.resume();\n      }\n    }\n  }\n\n  // Stop audio playback\n  stop(): void {\n    if (this.audioContext) {\n      this.audioContext.suspend();\n    }\n  }\n\n  // Get console output for display\n  getConsoleOutput(): string {\n    return this.consoleOutput;\n  }\n  \n  // Get all function tables for visualization\n  getFunctionTables(): FunctionTable[] {\n    const tables: FunctionTable[] = [];\n    this.functions.forEach((data, functionNum) => {\n      tables.push({\n        functionNum,\n        data: Array.from(data) // Convert Float32Array to regular array for easier handling\n      });\n    });\n    return tables;\n  }\n} ","<template>\n  <div class=\"musicv-test-container\">\n    <div class=\"editor-container\">\n      <div class=\"score-editor\" :style=\"{ flex: scoreEditorFlex }\">\n        <AceEditor\n          ref=\"scoreEditorRef\"\n          mode=\"editor\"\n          @keydown=\"handleKeyDown\"\n          @evaluate=\"evaluateSelection\"\n        />\n        \n        <!-- Mini oscilloscope visualizations in top right corner -->\n        <div class=\"mini-oscilloscopes\">\n          <div v-for=\"(table, index) in functionTables\" :key=\"index\" class=\"mini-oscilloscope\">\n            <div class=\"mini-oscilloscope-label\">F{{ table.functionNum }}</div>\n            <canvas :ref=\"el => { if (el) canvasRefs[table.functionNum] = el }\" \n                    width=\"80\" height=\"50\" \n                    class=\"mini-oscilloscope-canvas\">\n            </canvas>\n          </div>\n        </div>\n      </div>\n      \n      <div class=\"divider\" @mousedown=\"startDrag\"></div>\n      \n      <div class=\"console-editor\" :style=\"{ flex: consoleEditorFlex }\">\n        <div class=\"console-header\">\n          <button class=\"clear-btn\" @click=\"clearConsole\" title=\"Clear console\">üóëÔ∏è</button>\n        </div>\n        <AceEditor\n          ref=\"consoleEditorRef\"\n          mode=\"terminal\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, onMounted, nextTick, onUnmounted, reactive, watch } from 'vue'\nimport { MusicV } from '~/lib/musicV'\nimport AceEditor from '~/components/AceEditor.vue'\n\n// This score text is used for initialization\nconst scoreText = ref(`COM Define instrument 1\nINS 1 1 ;\nOSC P5 P6 B2 F2 P30 ;\nOUT B2 B1 ;\nEND ;\n\nCOM Define a square wave using GEN (value-time pairs)\nGEN 0 1 2 .999 0 .999 256 -.999 256 -.999 512 0 512 ;\n\nCOM Commented sine wave for reference\nCOM GEN 0 1 2 0 0 .999 50 .999 205 -.999 306 -.999 461 0 511 ;\n\nCOM Play notes with the square waveform\nNOT 0 1 440 0.05 0.15 ;\nNOT 0.2 1 500 0.045 0.15 ;\nNOT 0.6 1 550 0.045 0.15 ;\nNOT 1 1 600 0.045 0.15 ;\nNOT 1.4 1 650 0.045 0.15 ;\nNOT 1.8 1 700 0.045 0.15 ;\nNOT 2.2 1 750 0.01 0.15 ;\nNOT 2.6 1 800 0.045 0.15 ;\nNOT 2.9 1 850 0.045 0.15 ;\nNOT 3.4 1 900 0.045 0.15 ;\nNOT 3.8 1 950 0.045 0.15 ;\nNOT 4.2 1 1000 0.045 0.15 ;\nNOT 4.6 1 1050 0.045 0.15 ;\nNOT 5.0 1 800 0.055 0.15 ;\nTER 20 ;`)\n\nconst consoleOutput = ref('MUSIC V SCORE PROCESSING\\n=======================\\n')\nconst audioUrl = ref<string | null>(null)\nconst scoreEditorRef = ref(null)\nconst consoleEditorRef = ref(null)\n\n// Divider and resizing state\nconst isDragging = ref(false)\nconst scoreEditorFlex = ref(0.85)\nconst consoleEditorFlex = ref(0.15)\nconst startY = ref(0)\nconst startScoreEditorFlex = ref(0)\nconst startConsoleEditorFlex = ref(0)\n\n// Store function tables and canvas references\nconst functionTables = ref([])\nconst canvasRefs = reactive({})\n\nfunction handleKeyDown(event: KeyboardEvent) {\n  // Alt+Enter to evaluate selected text\n  if (event.altKey && event.key === 'Enter') {\n    event.preventDefault();\n    evaluateSelection();\n  }\n  \n  // Control+P to play audio again\n  if (event.ctrlKey && (event.key === 'p' || event.key === 'P')) {\n    console.log('Ctrl+P detected, playing audio');\n    event.preventDefault();\n    event.stopPropagation(); // Stop propagation to prevent AceEditor from handling it\n    playAudio();\n    return false; // Prevent default and stop bubbling\n  }\n}\n\nfunction playAudio() {\n  if (audioUrl.value) {\n    // Create a new audio context\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    \n    // Fetch the audio data from the blob URL\n    fetch(audioUrl.value)\n      .then(response => response.arrayBuffer())\n      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\n      .then(audioBuffer => {\n        // Create a buffer source node\n        const source = audioContext.createBufferSource();\n        source.buffer = audioBuffer;\n        \n        // Connect to the destination (speakers)\n        source.connect(audioContext.destination);\n        \n        // Play the audio\n        source.start(0);\n        \n        if (consoleEditorRef.value) {\n          consoleEditorRef.value.addTerminalOutput('Audio playback started (Ctrl+P)', 'success');\n        }\n      })\n      .catch(err => {\n        console.error('Error playing audio:', err);\n        if (consoleEditorRef.value) {\n          consoleEditorRef.value.addTerminalOutput(`Error playing audio: ${err.message}`, 'error');\n        }\n      });\n  } else if (consoleEditorRef.value) {\n    consoleEditorRef.value.addTerminalOutput('No audio available to play', 'error');\n  }\n}\n\nfunction startDrag(event: MouseEvent) {\n  isDragging.value = true\n  startY.value = event.clientY\n  startScoreEditorFlex.value = scoreEditorFlex.value\n  startConsoleEditorFlex.value = consoleEditorFlex.value\n  \n  // Add event listeners for dragging\n  document.addEventListener('mousemove', onDrag)\n  document.addEventListener('mouseup', stopDrag)\n  \n  // Prevent text selection during drag\n  document.body.style.userSelect = 'none'\n}\n\nfunction onDrag(event: MouseEvent) {\n  if (!isDragging.value) return\n  \n  const editorContainer = document.querySelector('.editor-container') as HTMLElement\n  if (!editorContainer) return\n  \n  const containerHeight = editorContainer.clientHeight\n  const deltaY = event.clientY - startY.value\n  const deltaRatio = deltaY / containerHeight\n  \n  // Calculate new flex values - corrected direction\n  let newScoreEditorFlex = startScoreEditorFlex.value + deltaRatio\n  let newConsoleEditorFlex = startConsoleEditorFlex.value - deltaRatio\n  \n  // Enforce minimum sizes (10% of container)\n  const minFlex = 0.1\n  if (newScoreEditorFlex < minFlex) {\n    newScoreEditorFlex = minFlex\n    newConsoleEditorFlex = 1 - minFlex\n  } else if (newConsoleEditorFlex < minFlex) {\n    newConsoleEditorFlex = minFlex\n    newScoreEditorFlex = 1 - minFlex\n  }\n  \n  scoreEditorFlex.value = newScoreEditorFlex\n  consoleEditorFlex.value = newConsoleEditorFlex\n}\n\nfunction stopDrag() {\n  isDragging.value = false\n  document.removeEventListener('mousemove', onDrag)\n  document.removeEventListener('mouseup', stopDrag)\n  document.body.style.userSelect = ''\n  \n  // Refresh the editors to ensure they render correctly after resize\n  nextTick(() => {\n    if (scoreEditorRef.value) {\n      scoreEditorRef.value.resize();\n    }\n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.resize();\n    }\n  })\n}\n\nonMounted(async () => {\n  // Initialize the score editor with the default score\n  await nextTick();\n  \n  if (scoreEditorRef.value) {\n    const aceEditorInstance = scoreEditorRef.value.aceEditorInstance();\n    if (aceEditorInstance) {\n      aceEditorInstance.setValue(scoreText.value);\n    }\n  }\n  \n  // Initialize the console with the welcome message\n  if (consoleEditorRef.value) {\n    clearConsole();\n  }\n  \n  // Add window event listeners for drag\n  window.addEventListener('mousemove', onDrag);\n  window.addEventListener('mouseup', stopDrag);\n});\n\nonUnmounted(() => {\n  // Remove window event listeners\n  window.removeEventListener('mousemove', onDrag);\n  window.removeEventListener('mouseup', stopDrag);\n  \n  // Clean up audio URL if it exists\n  if (audioUrl.value) {\n    URL.revokeObjectURL(audioUrl.value);\n  }\n});\n\nasync function generateSound() {\n  try {\n    if (consoleEditorRef.value) {\n      // Clear previous output\n      const terminalInstance = consoleEditorRef.value.terminalInstance();\n      if (terminalInstance) {\n        terminalInstance.setValue('');\n      }\n      \n      // Add new header\n      consoleEditorRef.value.addTerminalOutput('MUSIC V SCORE PROCESSING', 'success');\n      consoleEditorRef.value.addTerminalOutput('=======================', 'info');\n      consoleEditorRef.value.addTerminalOutput('Starting sound generation...', 'info');\n    }\n    \n    const musicV = new MusicV();\n    let currentScore = scoreText.value;\n    \n    if (scoreEditorRef.value) {\n      const aceEditorInstance = scoreEditorRef.value.aceEditor();\n      if (aceEditorInstance) {\n        currentScore = aceEditorInstance.getValue();\n      }\n    }\n    \n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.addTerminalOutput(`Parsing score:`, 'info');\n      consoleEditorRef.value.addTerminalOutput(currentScore, 'info');\n    }\n    \n    musicV.parseScore(currentScore);\n    \n    // Update console output\n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.addTerminalOutput(musicV.getConsoleOutput(), 'info');\n    }\n    \n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.addTerminalOutput('Generating audio samples...', 'info');\n    }\n    \n    // Generate sound\n    const audioData = await musicV.generateSound(3); // 3 seconds duration\n    \n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.addTerminalOutput(`Generated ${audioData.length} audio samples`, 'success');\n    }\n\n    // Convert Float32Array to WAV format\n    const wavData = createWavFile(audioData);\n    const blob = new Blob([wavData], { type: 'audio/wav' });\n    \n    // Create and set audio URL\n    if (audioUrl.value) {\n      URL.revokeObjectURL(audioUrl.value); // Clean up old URL\n    }\n    audioUrl.value = URL.createObjectURL(blob);\n    \n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.addTerminalOutput('Audio generation complete!', 'success');\n    }\n    \n    // Play the audio automatically\n    nextTick(() => {\n      const audioElement = document.querySelector('.audio-output audio');\n      if (audioElement) {\n        audioElement.volume = 0.8; // Set volume to 80%\n        audioElement.play()\n          .then(() => {\n            if (consoleEditorRef.value) {\n              consoleEditorRef.value.addTerminalOutput('Audio playback started', 'success');\n            }\n          })\n          .catch(err => {\n            console.error('Error playing audio:', err);\n            if (consoleEditorRef.value) {\n              consoleEditorRef.value.addTerminalOutput(`Error playing audio: ${err.message}`, 'error');\n            }\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error generating sound:', error);\n    const errorMessage = `Error: ${error.message || 'Unknown error'}\\n${error.stack || ''}`;\n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.addTerminalOutput(errorMessage, 'error');\n    }\n  }\n}\n\nasync function evaluateSelection() {\n  try {\n    // Clear previous audio\n    if (audioUrl.value) {\n      URL.revokeObjectURL(audioUrl.value);\n    }\n    audioUrl.value = null;\n    \n    // Get the current score from the editor\n    let currentScore = '';\n    if (scoreEditorRef.value) {\n      const aceEditorInstance = scoreEditorRef.value.aceEditorInstance();\n      if (aceEditorInstance) {\n        currentScore = aceEditorInstance.getValue();\n      }\n    }\n    \n    if (consoleEditorRef.value) {\n      // Clear previous output\n      const terminalInstance = consoleEditorRef.value.terminalInstance();\n      if (terminalInstance) {\n        terminalInstance.setValue('');\n      }\n      \n      // Add new header\n      consoleEditorRef.value.addTerminalOutput('MUSIC V SCORE PROCESSING', 'success');\n      consoleEditorRef.value.addTerminalOutput('=======================', 'info');\n    }\n    \n    // Create a new MusicV instance\n    const musicV = new MusicV();\n    \n    // Parse the score\n    try {\n      musicV.parseScore(currentScore);\n      \n      // Update console output\n      if (consoleEditorRef.value) {\n        consoleEditorRef.value.addTerminalOutput(musicV.getConsoleOutput(), 'info');\n      }\n      \n      // Visualize function tables if they exist\n      if (musicV.getFunctionTables && typeof musicV.getFunctionTables === 'function') {\n        const functionTables = musicV.getFunctionTables();\n        functionTables.forEach(table => {\n          visualizeFunctionTable(table.functionNum, table.data);\n        });\n      }\n      \n      if (consoleEditorRef.value) {\n        consoleEditorRef.value.addTerminalOutput('Generating audio samples...', 'info');\n      }\n      \n      // Generate sound\n      const audioBuffer = await musicV.generateSound(4); // 4 seconds of audio\n      \n      // Log some debug info about the audio buffer\n      if (consoleEditorRef.value) {\n        consoleEditorRef.value.addTerminalOutput(`Generated ${audioBuffer.length} audio samples`, 'info');\n        \n        // Check if we have any non-zero samples\n        let nonZeroCount = 0;\n        let maxValue = 0;\n        for (let i = 0; i < audioBuffer.length; i++) {\n          if (Math.abs(audioBuffer[i]) > 0.0001) {\n            nonZeroCount++;\n            maxValue = Math.max(maxValue, Math.abs(audioBuffer[i]));\n          }\n        }\n        \n        consoleEditorRef.value.addTerminalOutput(`Non-zero samples: ${nonZeroCount}`, 'info');\n        consoleEditorRef.value.addTerminalOutput(`Max amplitude: ${maxValue}`, 'info');\n      }\n      \n      // Convert to WAV and create URL\n      const wavBlob = createWavBlob(audioBuffer, 44100);\n      audioUrl.value = URL.createObjectURL(wavBlob);\n      \n      // Create a download link for the audio file\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `musicv-output-${timestamp}.wav`;\n      \n      if (consoleEditorRef.value) {\n        consoleEditorRef.value.addTerminalOutput('Audio generation complete.', 'info');\n        consoleEditorRef.value.addTerminalOutput(`Audio file is stored in memory as a Blob URL: ${audioUrl.value}`, 'info');\n        consoleEditorRef.value.addTerminalOutput(`Press Ctrl+P to play the audio.`, 'success');\n        consoleEditorRef.value.addTerminalOutput(`To save the file, right-click this link and select \"Save Link As\": `, 'info');\n        consoleEditorRef.value.addTerminalOutput(`<a href=\"${audioUrl.value}\" download=\"${filename}\" style=\"color:#ffb000;\">Download ${filename}</a>`, 'html');\n      }\n      \n      // Play the audio automatically\n      playAudio();\n    } catch (error) {\n      if (consoleEditorRef.value) {\n        consoleEditorRef.value.addTerminalOutput(`Error: ${error.message}`, 'error');\n      }\n      console.error('Error in MusicV processing:', error);\n    }\n    \n    // Get function tables after evaluation\n    functionTables.value = musicV.getFunctionTables()\n  } catch (error) {\n    console.error('Error in evaluation:', error);\n    if (consoleEditorRef.value) {\n      consoleEditorRef.value.addTerminalOutput(`Error: ${error.message}`, 'error');\n    }\n  }\n}\n\n// Function to visualize a function table as ASCII art in the console\nfunction visualizeFunctionTable(tableNum: number, tableData: Float32Array) {\n  if (!consoleEditorRef.value || !tableData) return;\n  \n  const width = 80; // Width of the visualization (increased for better resolution)\n  const height = 15; // Height of the visualization (increased for better visibility)\n  \n  // Create a 2D grid for the visualization\n  const grid = Array(height).fill(0).map(() => Array(width).fill(' '));\n  \n  // Sample the function table at regular intervals\n  const step = Math.floor(tableData.length / width);\n  \n  // Find min and max values for scaling\n  let minVal = Infinity;\n  let maxVal = -Infinity;\n  for (let i = 0; i < tableData.length; i++) {\n    minVal = Math.min(minVal, tableData[i]);\n    maxVal = Math.max(maxVal, tableData[i]);\n  }\n  \n  // Ensure we have a non-zero range\n  if (minVal === maxVal) {\n    minVal -= 0.5;\n    maxVal += 0.5;\n  }\n  \n  // Add a zero line if the range includes both positive and negative values\n  if (minVal < 0 && maxVal > 0) {\n    const zeroLineY = Math.floor((height - 1) * (1 - (0 - minVal) / (maxVal - minVal)));\n    if (zeroLineY >= 0 && zeroLineY < height) {\n      for (let x = 0; x < width; x++) {\n        grid[zeroLineY][x] = '-';\n      }\n    }\n  }\n  \n  // Plot the function table\n  for (let x = 0; x < width; x++) {\n    const idx = Math.min(tableData.length - 1, Math.floor(x * tableData.length / width));\n    if (idx < tableData.length) {\n      // Scale the value to the grid height\n      const value = tableData[idx];\n      const y = Math.floor((height - 1) * (1 - (value - minVal) / (maxVal - minVal)));\n      \n      // Ensure y is within bounds\n      const gridY = Math.max(0, Math.min(height - 1, y));\n      grid[gridY][x] = '*';\n    }\n  }\n  \n  // Convert the grid to a string\n  let visualization = `\\nFunction Table F${tableNum} (${tableData.length} points, range: ${minVal.toFixed(3)} to ${maxVal.toFixed(3)}):\\n`;\n  \n  // Add y-axis labels\n  for (let y = 0; y < height; y++) {\n    // Add y-axis value on the left\n    const yValue = maxVal - y * (maxVal - minVal) / (height - 1);\n    if (y === 0 || y === height - 1 || (minVal < 0 && maxVal > 0 && Math.abs(yValue) < 0.1)) {\n      visualization += `${yValue.toFixed(2).padStart(7)} |`;\n    } else {\n      visualization += '        |';\n    }\n    \n    // Add the grid row\n    visualization += grid[y].join('') + '\\n';\n  }\n  \n  // Add x-axis labels\n  visualization += '        +' + '-'.repeat(width) + '\\n';\n  visualization += '         ' + '0'.padEnd(Math.floor(width/4)) + \n                  (Math.floor(tableData.length/4)).toString().padEnd(Math.floor(width/4)) + \n                  (Math.floor(tableData.length/2)).toString().padEnd(Math.floor(width/4)) + \n                  (Math.floor(3*tableData.length/4)).toString().padEnd(Math.floor(width/4)) + \n                  tableData.length.toString() + '\\n';\n  \n  // Output to console\n  consoleEditorRef.value.addTerminalOutput(visualization, 'info');\n  \n  // Also output the raw values at key positions for debugging\n  const keyPositions = [0, 50, 205, 306, 461, 511];\n  let valueStr = 'Key values: ';\n  keyPositions.forEach(pos => {\n    if (pos < tableData.length) {\n      valueStr += `[${pos}]=${tableData[pos].toFixed(3)} `;\n    }\n  });\n  consoleEditorRef.value.addTerminalOutput(valueStr, 'info');\n}\n\nfunction createWavFile(audioData: Float32Array): ArrayBuffer {\n  const numChannels = 1\n  const sampleRate = 44100\n  const bitsPerSample = 32\n  const bytesPerSample = bitsPerSample / 8\n  const blockAlign = numChannels * bytesPerSample\n  const byteRate = sampleRate * blockAlign\n  const dataSize = audioData.length * bytesPerSample\n  const bufferSize = 44 + dataSize\n\n  const buffer = new ArrayBuffer(bufferSize)\n  const view = new DataView(buffer)\n\n  // Write WAV header\n  writeString(view, 0, 'RIFF')\n  view.setUint32(4, 36 + dataSize, true)\n  writeString(view, 8, 'WAVE')\n  writeString(view, 12, 'fmt ')\n  view.setUint32(16, 16, true)\n  view.setUint16(20, 3, true) // Format: IEEE float\n  view.setUint16(22, numChannels, true)\n  view.setUint32(24, sampleRate, true)\n  view.setUint32(28, byteRate, true)\n  view.setUint16(32, blockAlign, true)\n  view.setUint16(34, bitsPerSample, true)\n  writeString(view, 36, 'data')\n  view.setUint32(40, dataSize, true)\n\n  // Write audio data\n  const offset = 44\n  for (let i = 0; i < audioData.length; i++) {\n    view.setFloat32(offset + i * 4, audioData[i], true)\n  }\n\n  return buffer\n}\n\nfunction writeString(view: DataView, offset: number, string: string) {\n  for (let i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i))\n  }\n}\n\nfunction clearConsole() {\n  if (consoleEditorRef.value) {\n    const terminalInstance = consoleEditorRef.value.terminalInstance();\n    if (terminalInstance) {\n      terminalInstance.setValue('');\n    }\n    consoleEditorRef.value.addTerminalOutput('MUSIC V SCORE PROCESSING', 'info');\n    consoleEditorRef.value.addTerminalOutput('=======================', 'info');\n  }\n}\n\n// Function to convert Float32Array to WAV format\nfunction createWavBlob(audioData: Float32Array, sampleRate: number): Blob {\n  // Create buffer with space for the RIFF chunk\n  const bufferLength = audioData.length * 2;\n  const buffer = new ArrayBuffer(44 + bufferLength);\n  const view = new DataView(buffer);\n\n  // RIFF identifier\n  writeString(view, 0, 'RIFF');\n  // RIFF chunk length\n  view.setUint32(4, 36 + bufferLength, true);\n  // RIFF type\n  writeString(view, 8, 'WAVE');\n  // format chunk identifier\n  writeString(view, 12, 'fmt ');\n  // format chunk length\n  view.setUint32(16, 16, true);\n  // sample format (1 is PCM)\n  view.setUint16(20, 1, true);\n  // channel count\n  view.setUint16(22, 1, true);\n  // sample rate\n  view.setUint32(24, sampleRate, true);\n  // byte rate (sample rate * block align)\n  view.setUint32(28, sampleRate * 2, true);\n  // block align (channel count * bytes per sample)\n  view.setUint16(32, 2, true);\n  // bits per sample\n  view.setUint16(34, 16, true);\n  // data chunk identifier\n  writeString(view, 36, 'data');\n  // data chunk length\n  view.setUint32(40, bufferLength, true);\n\n  // Write the PCM samples\n  const volume = 0.8;\n  let index = 44;\n  for (let i = 0; i < audioData.length; i++) {\n    // Convert float to int16\n    const sample = Math.max(-1, Math.min(1, audioData[i])) * volume;\n    const int16Sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;\n    view.setInt16(index, int16Sample, true);\n    index += 2;\n  }\n\n  return new Blob([buffer], { type: 'audio/wav' });\n}\n\n// Watch for changes in function tables to update visualizations\nwatch(functionTables, (newTables) => {\n  // Allow the DOM to update with new canvases\n  setTimeout(() => {\n    newTables.forEach(table => {\n      drawOscilloscope(table)\n    })\n  }, 0)\n}, { deep: true })\n\n// Function to draw the oscilloscope visualization\nfunction drawOscilloscope(table) {\n  const canvas = canvasRefs[table.functionNum]\n  if (!canvas) return\n  \n  const ctx = canvas.getContext('2d')\n  const width = canvas.width\n  const height = canvas.height\n  const data = table.data\n  \n  // Clear the canvas\n  ctx.clearRect(0, 0, width, height)\n  \n  // Draw background and grid\n  ctx.fillStyle = '#1a1a1a'\n  ctx.fillRect(0, 0, width, height)\n  \n  // Draw grid lines - simplified for mini display\n  ctx.strokeStyle = '#333333'\n  ctx.lineWidth = 0.5\n  \n  // Vertical grid lines - fewer for mini display\n  for (let x = 0; x <= width; x += width / 4) {\n    ctx.beginPath()\n    ctx.moveTo(x, 0)\n    ctx.lineTo(x, height)\n    ctx.stroke()\n  }\n  \n  // Horizontal grid lines - fewer for mini display\n  for (let y = 0; y <= height; y += height / 2) {\n    ctx.beginPath()\n    ctx.moveTo(0, y)\n    ctx.lineTo(width, y)\n    ctx.stroke()\n  }\n  \n  // Draw center line (zero line)\n  ctx.strokeStyle = '#555555'\n  ctx.lineWidth = 0.5\n  ctx.beginPath()\n  ctx.moveTo(0, height / 2)\n  ctx.lineTo(width, height / 2)\n  ctx.stroke()\n  \n  // Find min and max values for scaling\n  let minVal = Infinity;\n  let maxVal = -Infinity;\n  for (let i = 0; i < data.length; i++) {\n    minVal = Math.min(minVal, data[i]);\n    maxVal = Math.max(maxVal, data[i]);\n  }\n  \n  // Ensure we have a non-zero range\n  if (minVal === maxVal) {\n    minVal -= 0.5;\n    maxVal += 0.5;\n  }\n  \n  // Draw the waveform\n  ctx.strokeStyle = '#00ff00' // Oscilloscope green\n  ctx.lineWidth = 1.5\n  ctx.beginPath()\n  \n  const dataLength = data.length\n  \n  for (let i = 0; i < dataLength; i++) {\n    const x = (i / (dataLength - 1)) * width\n    // Map data from [minVal, maxVal] to [height, 0]\n    const normalizedValue = (data[i] - minVal) / (maxVal - minVal)\n    const y = (1 - normalizedValue) * height\n    \n    if (i === 0) {\n      ctx.moveTo(x, y)\n    } else {\n      ctx.lineTo(x, y)\n    }\n  }\n  \n  ctx.stroke()\n  \n  // For mini display, show min/max values and table size\n  ctx.fillStyle = '#00ff00' // Green text to match oscilloscope\n  ctx.font = '8px monospace'\n  \n  // Draw min and max values\n  ctx.fillText(`${maxVal.toFixed(2)}`, 2, 8)\n  ctx.fillText(`${minVal.toFixed(2)}`, 2, height - 2)\n  \n  // Draw table size\n  ctx.fillText(`${dataLength}p`, width - 25, 8)\n  \n  // Draw key points for square wave\n  if (table.functionNum === 2) {\n    // Draw dots at key points for better visualization\n    ctx.fillStyle = '#ff5500'\n    \n    // Key points for square wave (0, 256, 512)\n    const keyPoints = [0, 256, 512]\n    keyPoints.forEach(pos => {\n      if (pos < dataLength) {\n        const x = (pos / (dataLength - 1)) * width\n        const normalizedValue = (data[pos] - minVal) / (maxVal - minVal)\n        const y = (1 - normalizedValue) * height\n        \n        ctx.beginPath()\n        ctx.arc(x, y, 2, 0, Math.PI * 2)\n        ctx.fill()\n      }\n    })\n  }\n}\n</script>\n\n<style scoped>\n.musicv-test-container {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  width: 100%;\n  background-color: transparent;\n}\n\n.editor-container {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  width: 100%;\n  position: relative;\n  background-color: transparent;\n}\n\n.score-editor, .console-editor {\n  position: relative;\n  min-height: 50px;\n  background-color: transparent;\n}\n\n.console-editor {\n  position: relative;\n  background-color: #000000;\n  border-top: 1px solid #333;\n}\n\n.console-header {\n  position: absolute;\n  top: 5px;\n  right: 5px;\n  z-index: 10;\n}\n\n.clear-btn {\n  background: none;\n  border: none;\n  cursor: pointer;\n  font-size: 16px;\n  opacity: 0.7;\n  transition: opacity 0.2s;\n  padding: 5px;\n  border-radius: 3px;\n  color: #ffb000;\n}\n\n.clear-btn:hover {\n  opacity: 1;\n  background-color: rgba(255, 176, 0, 0.2);\n}\n\n.divider {\n  height: 5px;\n  background-color: #333;\n  cursor: row-resize;\n  position: relative;\n}\n\n.divider:hover {\n  background-color: #555;\n}\n\n.divider:active {\n  background-color: #777;\n}\n\n.mini-oscilloscopes {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  z-index: 10;\n  display: flex;\n  flex-direction: column;\n  gap: 5px;\n}\n\n.mini-oscilloscope {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  background-color: rgba(0, 0, 0, 0.7);\n  border-radius: 3px;\n  padding: 2px;\n}\n\n.mini-oscilloscope-label {\n  font-family: 'IBM Plex Mono', monospace;\n  color: #00ff00;\n  font-size: 8px;\n  margin-bottom: 2px;\n}\n\n.mini-oscilloscope-canvas {\n  border: 1px solid #444;\n  border-radius: 2px;\n}\n</style>"],"names":["functionTables"],"mappings":"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"}